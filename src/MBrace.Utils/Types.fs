namespace Nessos.MBrace.Utils

    open System
    open System.IO
    open System.Net

    /// a heuristic host identifier
    /// an id generated by the local computer
    /// should be able to uniquely identify it within the context
    /// of all possible subnets/domain names that connect to it
    type HostId =
        private {
            HostName : string
            Interfaces : Set<string>
        }
    with
        static member Local =
            let hostname = Dns.GetHostName()
            let ifs = Dns.GetHostAddresses(hostname) |> Seq.map (fun i -> i.ToString()) |> Set.ofSeq
            { HostName = hostname ; Interfaces = ifs }


    /// inherit this class if you want to scrap all the comparison boilerplate
    type ProjectionComparison<'Id, 'Cmp when 'Cmp : comparison> (token : 'Cmp) =
        member private __.ComparisonToken = token

        interface IComparable with
            member x.CompareTo y =
                match y with
                | :? ProjectionComparison<'Id, 'Cmp> as y -> compare token y.ComparisonToken
                | _ -> invalidArg "y" "invalid comparand."

        override x.Equals y =
            match y with
            | :? ProjectionComparison<'Id, 'Cmp> as y -> token = y.ComparisonToken
            | _ -> false

        override x.GetHashCode() = hash token




    module FixedStream = 

        exception FixedSizeExceededException of unit

        /// A stream wrapper that fails when the size of the stream gt maxSize.
        /// 'Write'-only, no data actually written.
        type FixedSizeStream (maxSize : int64) =
            inherit Stream() with
                let mutable length = 0L
                member private __.LengthInternal
                    with get () = length
                    and  set l = 
                        if l > maxSize then raise(FixedSizeExceededException())
                        else length <- l
                let mutable position = 0L

                override this.CanRead  = false
                override this.CanSeek  = false
                override this.CanWrite = true
                override this.Length = this.LengthInternal
                override this.Position 
                    with get () = position
                    and  set v = position <- v
                override this.Flush () = ()
                override this.Seek(_,_) = raise(NotSupportedException())
                override this.SetLength l = this.LengthInternal <- l
                override this.Read(_,_,_) = raise(NotSupportedException())
                override this.Write(bytes, offset, count) =
                    let len = bytes.Length
                    if offset >= len || offset + count > len || offset < 0 then
                        raise(ArgumentException("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection."))
                    else 
                        position <- position + int64 count
                        if position > this.LengthInternal then
                            this.LengthInternal <- position




    module Substream = 

        /// A stream wrapper that sets as position 0L a given offset of the
        /// underlying stream.
        /// Please find a better name for this one.
        type Substream (underlying : Stream, offset : int) =
            inherit Stream() with
                override this.CanRead  = underlying.CanRead
                override this.CanSeek  = underlying.CanSeek
                override this.CanWrite = underlying.CanWrite
                
                override this.Length = underlying.Length - int64 offset
                
                override this.Position
                    with get () = underlying.Position - int64 offset
                    and  set p  = underlying.Position <- p

                override this.Flush () = underlying.Flush()
                
                override this.Seek(offset', origin) = 
                    match origin with
                    | SeekOrigin.Begin -> underlying.Seek(offset' + int64 offset, SeekOrigin.Begin)
                    | _ -> underlying.Seek(offset', origin)

                override this.SetLength l = underlying.SetLength(int64 offset + l)

                override this.Read(buffer,offset',count) = 
                    underlying.Read(buffer, offset' + offset, count)
                override this.Write(bytes, offset' , count) =
                    underlying.Write(bytes, offset' + offset, count)


        type StreamWrapper(stream : Stream, low : int64) =
            inherit Stream() with
                do stream.Position <- low

                override this.CanRead = stream.CanRead
                override this.CanSeek = stream.CanSeek
                override this.CanWrite = stream.CanWrite
                override this.Length = stream.Length - low
                override this.Position 
                    with get () = stream.Position - low
                    and  set p  = stream.Position <- p + low
                override this.Flush () = stream.Flush()
                override this.Seek(offset : int64, origin : SeekOrigin) =
                    match origin with
                    | SeekOrigin.Begin -> stream.Seek(offset + low, SeekOrigin.Begin) - low
                    | SeekOrigin.End -> stream.Seek(offset, SeekOrigin.End) - low
                    | SeekOrigin.Current 
                    | _ as origin -> stream.Seek(offset, SeekOrigin.Current) - low
                override this.SetLength(l : int64) = stream.SetLength(l + low)
                override this.Read(buffer : byte [], offset : int, count : int) =
                    stream.Read(buffer, offset, count)
                override this.Write(buffer : byte [], offset : int, count : int) =
                    stream.Write(buffer, offset, count)


    // Custom lazylist implementation to scrap powerpack dependency

    module LazyList =

        type LazyList<'T> =
            private
            | Empty
            | Tail of Lazy<LazyList<'T>>
            | NonEmpty of 'T * LazyList<'T>
        
        [<RequireQualifiedAccess>]
        module LazyList =
            let rec (|Nil|Cons|) (ll : LazyList<'T>) =
                match ll with
                | Empty -> Nil
                | Tail lt -> (|Nil|Cons|) lt.Value
                | NonEmpty(t,tl) -> Cons(t, tl)
            
            
            let ofSeq (xs : 'T seq) =
                let e = xs.GetEnumerator()
                let rec unfold () = lazy(
                    if e.MoveNext() then
                        NonEmpty(e.Current, Tail(unfold()))
                    else Empty )

                Tail(unfold ())


    #nowarn "44"

    module Queue =

        // immutable queue implementation

        [<Obsolete("use something more efficient")>]
        type Queue<'T> private (front : 'T list, back : 'T list) =
            // TODO: amortize !!!
            let list = lazy (front @ List.rev back)

            static let Q(xs : 'T list ,ys) = Queue<_>(xs,ys)

            static let rec append xs = function [] -> xs | y :: ys -> append (y :: xs) ys

            static member OfList xs = Q(xs,[])
            static member Empty = Q([],[])

            member __.IsEmpty = front.IsEmpty && back.IsEmpty
            member __.Length = front.Length + back.Length
            member __.Head = 
                if front.IsEmpty then
                    if back.IsEmpty then raise <| new ArgumentException("Queue is empty.")
                    else List.last back
                else front.Head
            member __.Last =
                if back.IsEmpty then
                    if front.IsEmpty then raise <| new ArgumentException("Queue is empty.")
                    else List.last front
                else back.Head

            member __.Enqueue x = 
                if list.IsValueCreated then Q(list.Value, [x])
                else Q(front, x :: back)
            member __.Enqueues zs = 
                if list.IsValueCreated then Q(list.Value, List.rev zs)
                else Q(front, append back zs)   
            member __.Dequeue() =
                if list.IsValueCreated then
                    match list.Value with
                    | [] -> failwith "Queue underflow."
                    | x :: xs -> Q(xs,[]), x
                else
                    match front, back with
                    | [],[] -> failwith "Queue underflow."
                    | [],_ -> Q(list.Value, []).Dequeue()
                    | x::xs, ys -> Q(xs,ys), x

            member __.Prepend x = 
                if list.IsValueCreated then
                    Q(x :: list.Value, [])
                else Q(x :: front, back)
            member __.ToList() = list.Value
            member __.ToArray() = Array.ofList list.Value
        
            override __.ToString () = list.Value.ToString()
            

        [<RequireQualifiedAccess>]
        module Queue =

            let inline private (|Q|) (q : Queue<_>) = q

            let ofList xs = Queue<_>.OfList xs
            let ofSeq xs = Queue<_>.OfList <| List.ofSeq xs
            let toList (Q q) = q.ToList()
            let toArray (Q q) = q.ToArray()


            let empty<'T> = Queue<'T>.Empty

            let isEmpty (Q q) = q.IsEmpty

            let enqueue x (Q q) = q.Enqueue x
            let enqueues xs (Q q) = q.Enqueues xs
            let dequeue (Q q) = q.Dequeue()

            let prepend x (Q q) = q.Prepend x
        
            let rec take n (Q q) =
                match n with
                | 0 -> q
                | n -> q.Dequeue() |> fst |> take (n-1)    

            let (|Empty|Cons|) (Q q) =
                if q.IsEmpty then Empty
                else
                    let q', x = q.Dequeue()
                    Cons(x,q')